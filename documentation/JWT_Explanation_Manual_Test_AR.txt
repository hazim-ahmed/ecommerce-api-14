
# شرح ملفات وعملية التحقق من JWT (JSON Web Token)

فيما يلي شرح تفصيلي للملفات المسؤولة عن عملية المصادقة باستخدام JWT وكيفية عملها في مشروعك، بالإضافة إلى خطوات لإجراء اختبار يدوي.

## 1. الملفات المسؤولة (Responsible Files)

تتم عملية المصادقة والتحقق من خلال تعاون ثلاثة ملفات رئيسية:

1.  **`controllers/AuthController.js`** (المتحكم في المصادقة):
    *   يحتوي على دالة `login` (تسجيل الدخول) ودالة `signup` (إنشاء الحساب).
    *   عندما يقوم المستخدم بإدخال بيانات صحيحة، يقوم هذا الملف باستدعاء دالة لإنشاء التوكن (`generateToken`) وإرساله للمستخدم.

2.  **`utils/jwt.js`** (أدوات JWT):
    *   يحتوي على دالة **`generateToken`**: التي تستخدم مكتبة `jsonwebtoken` لإنشاء التوكن وتشفيره باستخدام "المفتاح السري" (`JWT_SECRET`). تتضمن البيانات المشفرة (Payload) معرف المستخدم (`user_id`) والبريد الإلكتروني والصلاحية.
    *   يحتوي المنطق الخاص بتحديد مدة انتهاء صلاحية التوكن (مثلاً 7 أيام).

3.  **`middleware/authMiddleware.js`** (وسيط التحقق):
    *   هذا هو "الحارس" الذي يقف أمام الروابط المحمية.
    *   يحتوي على دالة **`authenticate`**.
    *   يقوم بقراءة التوكن من ترويسة الطلب (`Authorization Header`).
    *   يتحقق من صحة التوكن (التوقيع والصلاحية) باستخدام نفس المفتاح السري.
    *   إذا كان التوكن صحيحاً، يبحث عن المستخدم في قاعدة البيانات ويضيف بياناته إلى الطلب (`req.user`) ثم يسمح بالمرور (`next()`).

---

## 2. كيف تعمل عملية التحقق (The Verification Process)

عندما يرسل العميل (Frontend أو Postman) طلباً لرابط محمي (مثل `/api/auth/me`):

1.  **الإرسال (Request)**: يرسل العميل الطلب مع ترويسة (Header) كالتالي:
    `Authorization: Bearer <TOKEN_STRING>`

2.  **الاستلام (Interception)**: يستقبل `authMiddleware` الطلب قبل وصوله للدالة النهائية.

3.  **الاستخراج (Extraction)**: يقوم الكود بفصل كلمة `Bearer` عن التوكن الفعلي ليحصل على التوكن فقط.

4.  **التحقق (Verification)**:
    *   تستخدم الدالة `jwt.verify(token, secret)` التوكن والمفتاح السري الموجود في `process.env.JWT_SECRET`.
    *   إذا تم التلاعب بالتوكن (تغيير أي حرف)، سيفشل التحقق لأن التوقيع الرقمي لن يتطابق.
    *   إذا انتهت مدة صلاحية التوكن (Expired)، سيفشل التحقق.

5.  **التأكد من المستخدم (User Lookup)**:
    *   بعد فك تشفير التوكن بنجاح، نحصل على `user_id`.
    *   يقوم الكود بالاستعلام عن هذا المستخدم في قاعدة البيانات `User.findByPk(decoded.user_id)`.
    *   يتحقق مما إذا كان المستخدم موجوداً وما إذا كان حسابه فعالاً (`active`) وليس محظوراً.

6.  **السماح بالمرور**: إذا نجحت كل الخطوات السابقة، يتم إضافة بيانات المستخدم إلى `req.user` ويتم استدعاء `next()` لتنفيذ منطق الصفحة المطلوبة.

---

## 3. اختبار يدوي (Manual Test Plan)

يمكنك تجربة العملية يدوياً باستخدام Postman أو أي أداة مشابهة لتفهم ما يحدث.

**الخطوة 1: تسجيل الدخول (للحصول على التوكن)**
*   **الطريقة**: `POST`
*   **الرابط**: `http://localhost:3000/api/auth/login` (تأكد من المنفذ والرابط الصحيح لديك)
*   **الجسم (Body)** - JSON:
    ```json
    {
      "identifier": "test@example.com",
      "password": "password123"
    }
    ```
    *(استخدم بيانات مستخدم مسجل بالفعل في قاعدة بياناتك)*
*   **النتيجة**: ستتلقى رداً يحتوي على `token`. انسخ هذا التوكن (النص الطويل العشوائي).

**الخطوة 2: الدخول لرابط محمي (باستخدام التوكن)**
*   افتح تبويباً جديداً في Postman.
*   **الطريقة**: `GET`
*   **الرابط**: `http://localhost:3000/api/auth/me` (أو أي رابط محمي آخر)
*   **الترويسة (Headers)**:
    *   المفتاح (Key): `Authorization`
    *   القيمة (Value): `Bearer <الصق_التوكن_هنا>`
    *(تأكد من وجود مسافة بين كلمة Bearer والتوكن)*
*   **الإرسال**: اضغط Send.
*   **النتيجة المتوقعة**: ستظهر بيانات المستخدم الخاصة بك (هذا يعني أن التوكن تم قبوله والتحقق منه بنجاح).

**الخطوة 3: تجربة توكن غير صالح (Invalid Token)**
*   في نفس طلب الخطوة 2، قم بتغيير حرف واحد فقط من التوكن الموجود في الـ Header.
*   **الإرسال**: اضغط Send.
*   **النتيجة المتوقعة**: ستتلقى رسالة خطأ `401 Unauthorized` (Invalid token).

**الخطوة 4: تجربة بدون توكن**
*   قم بحذف ترويسة `Authorization` تماماً.
*   **الإرسال**: اضغط Send.
*   **النتيجة المتوقعة**: ستتلقى رسالة خطأ `401 Unauthorized` (No token provided).
